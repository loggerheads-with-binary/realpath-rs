<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Path Dedot"><meta name="keywords" content="rust, rustlang, rust-lang, path_dedot"><title>path_dedot - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-93196c7a1c3542a8.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../path_dedot/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../path_dedot/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate path_dedot</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 3.0.18</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#statics">Statics</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">path_dedot</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/path_dedot/lib.rs.html#1-305">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="path-dedot"><a href="#path-dedot">Path Dedot</a></h2>
<p>This is a library for extending <code>Path</code> and <code>PathBuf</code> in order to parse the path which contains dots.</p>
<p>Please read the following examples to know the parsing rules.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>If a path starts with a single dot, the dot means your program’s <strong>current working directory</strong> (CWD).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;
<span class="kw">use </span>std::env;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;./path/to/123/456&quot;</span>);
<span class="macro">assert_eq!</span>(Path::join(env::current_dir().unwrap().as_path(), Path::new(<span class="string">&quot;path/to/123/456&quot;</span>)).to_str().unwrap(), p.parse_dot().unwrap().to_str().unwrap());</code></pre></div>
<p>If a path starts with a pair of dots, the dots means the parent of the CWD. If the CWD is <strong>root</strong>, the parent is still <strong>root</strong>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;
<span class="kw">use </span>std::env;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;../path/to/123/456&quot;</span>);

<span class="kw">let </span>cwd = env::current_dir().unwrap();

<span class="kw">let </span>cwd_parent = cwd.parent();

<span class="kw">match </span>cwd_parent {
   <span class="prelude-val">Some</span>(cwd_parent) =&gt; {
      <span class="macro">assert_eq!</span>(Path::join(<span class="kw-2">&amp;</span>cwd_parent, Path::new(<span class="string">&quot;path/to/123/456&quot;</span>)).to_str().unwrap(), p.parse_dot().unwrap().to_str().unwrap());
   }
   <span class="prelude-val">None </span>=&gt; {
      <span class="macro">assert_eq!</span>(Path::join(Path::new(<span class="string">&quot;/&quot;</span>), Path::new(<span class="string">&quot;path/to/123/456&quot;</span>)).to_str().unwrap(), p.parse_dot().unwrap().to_str().unwrap());
   }
}</code></pre></div>
<p>In addition to starting with, the <strong>Single Dot</strong> and <strong>Double Dots</strong> can also be placed to other positions. <strong>Single Dot</strong> means noting and will be ignored. <strong>Double Dots</strong> means the parent.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;/path/to/../123/456/./777&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/path/123/456/777&quot;</span>, p.parse_dot().unwrap().to_str().unwrap());</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;/path/to/../123/456/./777/..&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/path/123/456&quot;</span>, p.parse_dot().unwrap().to_str().unwrap());</code></pre></div>
<p>You should notice that <code>parse_dot</code> method does <strong>not</strong> aim to get an <strong>absolute path</strong>. A path which does not start with a <code>MAIN_SEPARATOR</code>, <strong>Single Dot</strong> and <strong>Double Dots</strong>, will not have each of them after the <code>parse_dot</code> method is used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;path/to/../123/456/./777/..&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;path/123/456&quot;</span>, p.parse_dot().unwrap().to_str().unwrap());</code></pre></div>
<p><strong>Double Dots</strong> which is not placed at the start cannot get the parent beyond the original path. Why not? With this constraint, you can insert an absolute path to the start as a virtual root in order to protect your file system from being exposed.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;path/to/../../../../123/456/./777/..&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;123/456&quot;</span>, p.parse_dot().unwrap().to_str().unwrap());</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;/path/to/../../../../123/456/./777/..&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/123/456&quot;</span>, p.parse_dot().unwrap().to_str().unwrap());</code></pre></div>
<h4 id="starting-from-a-given-current-working-directory"><a href="#starting-from-a-given-current-working-directory">Starting from a given current working directory</a></h4>
<p>With the <code>parse_dot_from</code> function, you can provide the current working directory that the relative paths should be resolved from.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::env;
<span class="kw">use </span>std::path::Path;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">let </span>p = Path::new(<span class="string">&quot;../path/to/123/456&quot;</span>);
<span class="kw">let </span>cwd = env::current_dir().unwrap();

<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, p.parse_dot_from(<span class="kw-2">&amp;</span>cwd).unwrap().to_str().unwrap());</code></pre></div>
<h3 id="caching"><a href="#caching">Caching</a></h3>
<p>By default, the <code>parse_dot</code> method creates a new <code>PathBuf</code> instance of the CWD every time in its operation. The overhead is obvious. Although it allows us to safely change the CWD at runtime by the program itself (e.g. using the <code>std::env::set_current_dir</code> function) or outside controls (e.g. using gdb to call <code>chdir</code>), we don’t need that in most cases.</p>
<p>In order to parse paths with better performance, this crate provides three ways to cache the CWD.</p>
<h4 id="once_cell_cache"><a href="#once_cell_cache">once_cell_cache</a></h4>
<p>Enabling the <code>once_cell_cache</code> feature can let this crate use <code>once_cell</code> to cache the CWD. It’s thread-safe and does not need to modify any code, but once the CWD is cached, it cannot be changed anymore at runtime.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.path-dedot]
version = &quot;*&quot;
features = [&quot;once_cell_cache&quot;]
</code></pre></div><h4 id="lazy_static_cache"><a href="#lazy_static_cache">lazy_static_cache</a></h4>
<p>Enabling the <code>lazy_static_cache</code> feature can let this crate use <code>lazy_static</code> to cache the CWD. It’s thread-safe and does not need to modify any code, but once the CWD is cached, it cannot be changed anymore at runtime.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.path-dedot]
version = &quot;*&quot;
features = [&quot;lazy_static_cache&quot;]
</code></pre></div><h4 id="unsafe_cache"><a href="#unsafe_cache">unsafe_cache</a></h4>
<p>Enabling the <code>unsafe_cache</code> feature can let this crate use a mutable static variable to cache the CWD. It allows the program to change the CWD at runtime by the program itself, but it’s not thread-safe.</p>
<p>You need to use the <code>update_cwd</code> function to initialize the CWD first. The function should also be used to update the CWD after the CWD is changed.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.path-dedot]
version = &quot;*&quot;
features = [&quot;unsafe_cache&quot;]
</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::Path;

<span class="kw">use </span>path_dedot::<span class="kw-2">*</span>;

<span class="kw">unsafe </span>{
    update_cwd();
}

<span class="kw">let </span>p = Path::new(<span class="string">&quot;./path/to/123/456&quot;</span>);

<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, p.parse_dot().unwrap().to_str().unwrap());

std::env::set_current_dir(<span class="string">&quot;/&quot;</span>).unwrap();

<span class="kw">unsafe </span>{
    update_cwd();
}

<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, p.parse_dot().unwrap().to_str().unwrap());</code></pre></div>
<h3 id="benchmark"><a href="#benchmark">Benchmark</a></h3><h5 id="no-cache"><a href="#no-cache">No-cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench
</code></pre></div><h5 id="once_cell_cache-1"><a href="#once_cell_cache-1">once_cell_cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench --features once_cell_cache
</code></pre></div><h5 id="lazy_static_cache-1"><a href="#lazy_static_cache-1">lazy_static_cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench --features lazy_static_cache
</code></pre></div><h5 id="unsafe_cache-1"><a href="#unsafe_cache-1">unsafe_cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench --features unsafe_cache
</code></pre></div></div></details><h2 id="statics" class="small-section-header"><a href="#statics">Statics</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="static" href="static.MAIN_SEPARATOR.html" title="path_dedot::MAIN_SEPARATOR static">MAIN_SEPARATOR</a></div><div class="item-right docblock-short">The main separator for the target OS.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ParseDot.html" title="path_dedot::ParseDot trait">ParseDot</a></div><div class="item-right docblock-short">Let <code>Path</code> and <code>PathBuf</code> have <code>parse_dot</code> method.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ParsePrefix.html" title="path_dedot::ParsePrefix trait">ParsePrefix</a></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="path_dedot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0 (2c8cc3432 2023-03-06)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-08ddfdda51b8ee2e.css" ></div></body></html>